<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Te amo, Mar√≠a üíò</title>

<style>
html,body{margin:0;height:100%;overflow:hidden;}
body{
  background: radial-gradient(circle at 50% 30%, #3a0a6a 0%, #14002a 60%, #000 100%);
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
}
canvas{position:fixed;inset:0;width:100vw;height:100vh;display:block;}
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  let W,H,DPR;
  function resize(){
    DPR = Math.min(2,window.devicePixelRatio||1);
    W = innerWidth;
    H = innerHeight;
    canvas.width = Math.floor(W*DPR);
    canvas.height = Math.floor(H*DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  resize();

  const TEXT = "Te amo, Mar√≠a";

  // ===== Timing (~14s) =====
  const HOLD_TIME = 3000;

  const TEXT_SPEED = 22;                     // un pel√≠n m√°s lento, pero m√°s limpio visual
  const TEXT_BURST = (W < 480) ? 4 : 3;      // menos densidad

  const HEART_SPEED = 35;
  const HEART_BURST = 6;

  // Coraz√≥n 3 l√≠neas
  const HEART_STEP = 0.08;
  const LINE_SPACING = 12;
  const HEART_LINES = [-1,0,1];

  // Tama√±os: m√°s peque√±os para que se lea
  function textHeartSize(){ return (W < 480) ? 7 : 8; } // M√ÅS PEQUE√ëO
  function bigHeartSize(){  return 10; }               // mismo tama√±o en coraz√≥n grande (ligeramente menor)

  // Fondo estrellas
  let stars=[];
  function rebuildStars(){
    stars = Array.from({length:170},()=>({
      x:Math.random()*W,
      y:Math.random()*H,
      r:Math.random()*1.3,
      a:Math.random()*0.55+0.2
    }));
  }
  rebuildStars();

  function drawBackground(){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle="#fff";
    for(const s of stars){
      ctx.globalAlpha=s.a;
      ctx.beginPath();
      ctx.arc(s.x,s.y,s.r,0,Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha=1;
  }

  // Coraz√≥n mini
  function drawHeart(x,y,size){
    ctx.save();
    ctx.translate(x,y);
    ctx.shadowBlur=14;
    ctx.shadowColor="rgba(255,60,141,0.55)";
    ctx.scale(size/20,size/20);
    ctx.fillStyle="#ff3c8d";
    ctx.beginPath();
    ctx.moveTo(0,6);
    ctx.bezierCurveTo(0,0,-10,-2,-10,6);
    ctx.bezierCurveTo(-10,15,0,20,0,25);
    ctx.bezierCurveTo(0,20,10,15,10,6);
    ctx.bezierCurveTo(10,-2,0,0,0,6);
    ctx.fill();
    ctx.restore();
  }

  function drawCats(){
    const y=H*0.88;
    ctx.font=`${Math.min(W*0.07,50)}px "Apple Color Emoji","Segoe UI Emoji"`;
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.fillText("üòπ",W*0.15,y);
    ctx.fillText("üòª",W*0.85,y);
  }

  function shuffle(a){
    for(let i=a.length-1;i>0;i--){
      const j=Math.random()*(i+1)|0;
      [a[i],a[j]]=[a[j],a[i]];
    }
  }

  // ‚úÖ TEXTO menos denso: step m√°s grande
  function buildTextTargets(){
    const off=document.createElement("canvas");
    off.width=W; off.height=H;
    const o=off.getContext("2d");

    o.clearRect(0,0,W,H);
    o.fillStyle="white";
    const fontSize = Math.min(W*0.12, 92);
    o.font=`700 ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif`;
    o.textAlign="center";
    o.textBaseline="middle";
    o.fillText(TEXT,W/2,H*0.25);

    const data=o.getImageData(0,0,W,H).data;
    const pts=[];

    // üî• clave: step mayor = menos puntos = m√°s legible
    const step = (W < 480) ? 6 : 7;

    for(let y=0;y<H;y+=step){
      for(let x=0;x<W;x+=step){
        if(data[(y*W+x)*4+3]>120) pts.push({x,y});
      }
    }
    shuffle(pts);
    return pts;
  }

  function heartPoint(t){
    const x=16*Math.pow(Math.sin(t),3);
    const y=13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
    return {x,y};
  }

  function buildHeartTargets(){
    const base=[];
    for(let t=0;t<Math.PI*2;t+=HEART_STEP){
      const p=heartPoint(t);
      const eps=0.001;
      const p2=heartPoint(t+eps);
      const tx=p2.x-p.x;
      const ty=p2.y-p.y;
      let nx=-ty, ny=tx;
      const len=Math.hypot(nx,ny)||1;
      nx/=len; ny/=len;
      base.push({px:p.x,py:p.y,nx,ny});
    }

    const cx=W/2;
    const cy=H*0.62;
    const scale=Math.min(W,H)*0.32;

    const targets=[];
    for(const b of base){
      const x0=cx+(b.px/18)*scale;
      const y0=cy-(b.py/18)*scale;
      for(const l of HEART_LINES){
        targets.push({
          x:x0+b.nx*(l*LINE_SPACING),
          y:y0+b.ny*(l*LINE_SPACING)
        });
      }
    }
    shuffle(targets);
    return targets;
  }

  let phase="text";
  let textTargets=[],heartTargets=[];
  let builtText=[],builtHeart=[];
  let flying=[];
  let finishedAt=0;

  function spawn(target,kind){
    const fromLeft=Math.random()<0.5;
    const start={x:fromLeft?W*0.15:W*0.85,y:H*0.85};
    const mid={
      x:(start.x+target.x)/2+(fromLeft?1:-1)*W*0.12,
      y:(start.y+target.y)/2-H*0.22
    };
    flying.push({t:0,dur:280+Math.random()*260,from:start,mid,to:target,kind});
  }

  function reset(){
    rebuildStars();
    textTargets=buildTextTargets();
    heartTargets=buildHeartTargets();
    builtText=[];
    builtHeart=[];
    flying=[];
    phase="text";
    finishedAt=0;
  }

  addEventListener("resize",()=>{resize();reset();});
  reset();

  let lastText=0,lastHeart=0;

  function animate(ts){
    drawBackground();

    if(phase==="text"){
      if(ts-lastText>TEXT_SPEED){
        lastText=ts;
        for(let i=0;i<TEXT_BURST;i++){
          if(!textTargets.length) break;
          spawn(textTargets.pop(),"text");
        }
      }
      if(!textTargets.length && !flying.length) phase="heart";
    }

    if(phase==="heart"){
      if(ts-lastHeart>HEART_SPEED){
        lastHeart=ts;
        for(let i=0;i<HEART_BURST;i++){
          if(!heartTargets.length) break;
          spawn(heartTargets.pop(),"heart");
        }
      }
      if(!heartTargets.length && !flying.length){
        phase="hold";
        finishedAt=ts;
      }
    }

    for(let i=flying.length-1;i>=0;i--){
      const p=flying[i];
      p.t+=16;
      const u=Math.min(1,p.t/p.dur);

      const x=(1-u)*(1-u)*p.from.x+2*(1-u)*u*p.mid.x+u*u*p.to.x;
      const y=(1-u)*(1-u)*p.from.y+2*(1-u)*u*p.mid.y+u*u*p.to.y;

      drawHeart(x,y, p.kind==="text" ? textHeartSize() : bigHeartSize());

      if(u>=1){
        if(p.kind==="text") builtText.push(p.to);
        else builtHeart.push(p.to);
        flying.splice(i,1);
      }
    }

    for(const b of builtText)  drawHeart(b.x,b.y,textHeartSize());
    for(const b of builtHeart) drawHeart(b.x,b.y,bigHeartSize());

    drawCats();

    if(phase==="hold" && ts-finishedAt>HOLD_TIME){
      reset();
    }

    requestAnimationFrame(animate);
  }

  requestAnimationFrame(animate);
})();
</script>
</body>
</html>
